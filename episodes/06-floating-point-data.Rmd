---
title: 'Floating Point Data'
teaching: 10
exercises: 5
---

:::::::::::::::::::::::::::::::::::::: questions 

- What are the best practices when working with floating point data?
- How do you compare objects in libraries like `pandas` and `numpy`?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Learn how to test floating point data with tolerances.
- Learn how to compare objects in libraries like `pandas` and `numpy`.

::::::::::::::::::::::::::::::::::::::::::::::::

## Floating Point Data

Real numbers are encountered very frequently in research, but it's quite likely
that they won't be 'nice' numbers like 2.0 or 0.0. Instead, the outcome of our
code might be something like `2.34958124890e-31`, and we may only be confident
in that answer to a certain precision.

Computers typically represent real numbers using a 'floating point' representation,
which truncates their precision to a certain number of decimal places. Floating point
arithmetic errors can cause a significant amount of noise in the last few decimal
places. This can be affected by:

- Choice of algorithm.
- Precise order of operations.
- Order in which parallel processes finish.
- Inherent randomness in the calculation.

We could therefore test our code using `assert result == 2.34958124890e-31`,
but it's possible that this test could erroneously fail in future for reasons
outside our control. This lesson will teach best practices for handling this
type of data.

Libraries like `numpy` and `pandas` are commonly used to interact with large quantities
of floating point numbers, and they provide special functions to assist with testing.

### Relative and Absolute Tolerances

Rather than testing that a floating point number is exactly equal to another,
it is preferable to test that it is within a certain tolerance. In most cases,
it is best to use a _relative_ tolerance:

```python
from math import fabs

def test_float_rtol():
    actual = my_function()
    expected = 7.31926e12  # Reference solution
    rtol = 1e-3
    # Use fabs to ensure a positive result!
    assert fabs((actual - expected) / expected) < rtol
```

In some situations, such as testing a number is close to zero without caring
about exactly how large it is, it is preferable to test within an _absolute_
tolerance:

```python
from math import fabs

def test_float_atol():
    actual = my_function()
    expected = 0.0  # Reference solution
    atol = 1e-5
    # Use fabs to ensure a positive result!
    assert fabs(actual - expected) < atol
```


Let's practice with a function that estimates the value of pi (very
inefficiently!).

::::::::::::::::::::::::::::::::::::: challenge 

## Testing with tolerances

- Write this function to a file `estimate_pi.py`:

```
import random

def estimate_pi(iterations):
    num_inside = 0
    for _ in range(iterations):
        x = random.random()
        y = random.random()
        if x**2 + y**2 < 1:
            num_inside += 1
    return 4 * num_inside / iterations
```

- Add a file `test_estimate_pi.py`, and include a test for this function using
  both absolute and relative tolerances.
- Find an appropriate number of iterations so that the test finishes quickly,
  but keep in mind that both `atol` and `rtol` will need to be modified accordingly!

:::::::::::::::::::::::: solution 

```python
import random
from math import fabs

from estimate_pi import estimate_pi

def test_estimate_pi():
    random.seed(0)
    expected = 3.141592654
    actual = estimate_pi(iterations=10000)
    # Test absolute tolerance
    atol = 1e-2
    assert fabs(actual - expected) < atol
    # Test relative tolerance
    rtol = 5e-3
    assert fabs((actual - expected) / expected) < rtol
```

In this case the absolute and relative tolerances should be similar, as
the expected result is close in magnitude to 1.0, but in principle they could
be very different!

:::::::::::::::::::::::::::::::::

The built-in function `math.isclose` can be used to simplify these checks:

```python
assert math.isclose(a, b, rel_tol=rtol, abs_tol=atol)
```

Both `rel_tol` and `abs_tol` may be provided, and it will return `True`
if either of the conditions are satisfied.

::::::::::::::::::::::::::::::::::::: challenge 

## Using `math.isclose`

- Adapt the test you wrote in the previous challenge to make use of
  the `math.isclose` function.

:::::::::::::::::::::::: solution 

```python
import random
from math import fabs

from estimate_pi import estimate_pi

def test_estimate_pi():
    random.seed(0)
    expected = 3.141592654
    actual = estimate_pi(iterations=10000)
    atol = 1e-2
    rtol = 5e-3
    assert math.isclose(actual, expected, abs_tol=atol rel_tol=rtol)
```

:::::::::::::::::::::::::::::::::

### NumPy

NumPy is a common library used in research. Instead of the usual `assert a ==
b`, NumPy has its own testing functions that are more suitable for comparing
NumPy arrays. These functions are the ones you are most likely to use:

- `numpy.testing.assert_array_equal` is used to compare two NumPy arrays or array-like objects (such as list, tuples, etc).
- `numpy.testing.assert_allclose` is used to compare two NumPy arrays or array-like objects with a tolerance for floating point numbers.

These may also be used on individual floating point numbers if you choose.

Here are some examples of how to use these functions:

```python

def test_numpy_arrays():
    """Test that numpy arrays are equal"""
    # Create two numpy arrays
    array1 = np.array([1, 2, 3])
    array2 = np.array([1, 2, 3])
    # Check that the arrays are equal
    np.testing.assert_array_equal(array1, array2)

# Note that np.testing.assert_array_equal even works with multidimensional numpy arrays!

def test_2d_numpy_arrays():
    """Test that 2d numpy arrays are equal"""
    # Create two 2d numpy arrays
    array1 = np.array([[1, 2], [3, 4]])
    array2 = np.array([[1, 2], [3, 4]])
    # Check that the nested arrays are equal
    np.testing.assert_array_equal(array1, array2)

def test_numpy_arrays_with_tolerance():
    """Test that numpy arrays are equal with tolerance"""
    # Create two numpy arrays
    array1 = np.array([1.0, 2.0, 3.0])
    array2 = np.array([1.00009, 2.0005, 3.0001])
    # Check that the arrays are equal with tolerance
    np.testing.assert_allclose(array1, array2, atol=1e-3)
```

::::::::::::::::::::::::::::::::::::: callout

### Data structures with numpy arrays

When you have data structures that contain numpy arrays, such as lists or dictionaries, you cannot use `==` to compare them.
Instead, you can use `numpy.testing.assert_equal` to compare the data structures.

```python
def test_dictionaries_with_numpy_arrays():
    """Test that dictionaries with numpy arrays are equal"""
    # Create two dictionaries with numpy arrays
    dict1 = {"a": np.array([1, 2, 3]), "b": np.array([4, 5, 6])}
    dict2 = {"a": np.array([1, 2, 3]), "b": np.array([4, 5, 6])}
    # Check that the dictionaries are equal
    np.testing.assert_equal(dict1, dict2)
```

::::::::::::::::::::::::::::::::::::::::::::::::


### pandas

Pandas is another common library used in research for storing and manipulating datasets.
Pandas has its own testing functions that are more suitable for comparing Pandas objects.
These two functions are the ones you are most likely to use:
- `pandas.testing.assert_frame_equal` is used to compare two Pandas DataFrames.
- `pandas.testing.assert_series_equal` is used to compare two Pandas Series.


Here are some examples of how to use these functions:

```python

def test_pandas_dataframes():
    """Test that pandas DataFrames are equal"""
    # Create two pandas DataFrames
    df1 = pd.DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
    df2 = pd.DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
    # Check that the DataFrames are equal
    pd.testing.assert_frame_equal(df1, df2)

def test_pandas_series():
    """Test that pandas Series are equal"""
    # Create two pandas Series
    s1 = pd.Series([1, 2, 3])
    s2 = pd.Series([1, 2, 3])
    # Check that the Series are equal
    pd.testing.assert_series_equal(s1, s2)
```

There is no equivalent to `np.assert_allclose` in Pandas. If you need to compare DataFrames
or Series containing floating point data, it is recommended to use the `np.testing` functions directly
on the Pandas objects.


::::::::::::::::::::::::::::::::::::: challenge 

### Checking if NumPy arrays are equal

In `statistics/stats.py` add this function to calculate the cumulative sum of a NumPy array:

```python
import numpy as np

def calculate_cumulative_sum(array: np.ndarray) -> np.ndarray:
    """Calculate the cumulative sum of a numpy array"""
    
    # don't use the built-in numpy function
    result = np.zeros(array.shape)
    result[0] = array[0]
    for i in range(1, len(array)):
        result[i] = result[i-1] + array[i]

    return result
```

Then write a test for this function by comparing NumPy arrays.

:::::::::::::::::::::::: solution

```python
import numpy as np
from stats import calculate_cumulative_sum

def test_calculate_cumulative_sum():
    """Test calculate_cumulative_sum function"""
    array = np.array([1, 2, 3, 4, 5])
    expected_result = np.array([1, 3, 6, 10, 15])
    np.testing.assert_array_equal(calculate_cumulative_sum(array), expected_result)
```

:::::::::::::::::::::::::::::::::

### Checking if Pandas DataFrames are equal

In `statistics/stats.py` add this function to calculate the average score of each player in a Pandas DataFrame:

```python
import pandas as pd

def calculate_player_average_scores(df: pd.DataFrame) -> pd.DataFrame:
    """Calculate the average score of each player in a pandas DataFrame.
    
    Example input:
    |   | player  | score_1 | score_2 |
    |---|---------|---------|---------|
    | 0 | Alice   | 1       | 2       |
    | 1 | Bob     | 3       | 4       |

    Example output:
    |   | player  | score_1 | score_2 | average_score |
    |---|---------|---------|---------|---------------|
    | 0 | Alice   | 1       | 2       | 1.5           |
    | 1 | Bob     | 3       | 4       | 3.5           |
    """

    df["average_score"] = df[["score_1", "score_2"]].mean(axis=1)

    return df
```

Then write a test for this function by comparing Pandas DataFrames.

Hint: You can create a dataframe like this:

```python
df = pd.DataFrame({
    "player": ["Alice", "Bob"],
    "score_1": [1, 3],
    "score_2": [2, 4]
})
```

:::::::::::::::::::::::: solution

```python
import pandas as pd
from stats import calculate_player_average_scores

def test_calculate_player_average_scores():
    """Test calculate_player_average_scores function"""
    df = pd.DataFrame({
        "player": ["Alice", "Bob"],
        "score_1": [1, 3],
        "score_2": [2, 4]
    })
    expected_result = pd.DataFrame({
        "player": ["Alice", "Bob"],
        "score_1": [1, 3],
        "score_2": [2, 4],
        "average_score": [1.5, 3.5]
    })
    pd.testing.assert_frame_equal(calculate_player_average_scores(df), expected_result)
```

:::::::::::::::::::::::::::::::::


::::::::::::::::::::::::::::::::::::::::::::::::


::::::::::::::::::::::::::::::::::::: keypoints 

- When comparing floating point data, you should use relative/absolute tolerances instead of testing for equality.
- Numpy arrays cannot be compared using the `==` operator. Instead, use `numpy.testing.assert_array_equal` and `numpy.testing.assert_allclose`.
- Pandas DataFrames and Series should be compared using `pandas.testing.assert_frame_equal` and `pandas.testing.assert_series_equal`.

::::::::::::::::::::::::::::::::::::::::::::::::

